package pl.edu.agh.kis.generator;

import org.stringtemplate.v4.ST;
import org.stringtemplate.v4.STGroup;
import org.stringtemplate.v4.STGroupFile;
import pl.edu.agh.kis.model.*;
import static pl.edu.agh.kis.generator.GeneratorException.ExceptionType.*;

import java.util.*;

public class Generator {
    public static String generate(Model model, TargetConfig config) {
        GeneratorInternal gen = new GeneratorInternal(config);
        return gen.generate(model);
    }

    private static class GeneratorInternal {
        private final STGroup group;
        private final Map<String, Counter> counters;
        private final Map<String, Integer> counterIncrements;
        private final Set<String> includes;

        private final TargetConfig config;

        public GeneratorInternal(TargetConfig config) {
            this.config = config;

            try {
                this.group = new STGroupFile(config.getTemplateFile());
            } catch (IllegalArgumentException e) {
                DebugInfo debugInfo = new DebugInfo(0, 0);
                debugInfo.put("message", e.getMessage());
                throw GeneratorException.of(TEMPLATE_FILE_ERROR, debugInfo);
            }

            this.counters = new HashMap<>();
            this.counterIncrements = new HashMap<>();

            for (var entry : config.getCounterConfig().entrySet()) {
                Counter counter = new Counter(0);
                for (var pattern : entry.getKey()) {
                    counters.put(pattern, counter);
                    counterIncrements.put(pattern, entry.getValue());
                }
            }

            this.includes = new HashSet<>();
        }

        public String generate(Model model) {
            ST program = group.getInstanceOf("Program");

            if (program == null) {
                DebugInfo debugInfo = new DebugInfo(0,0);
                debugInfo.put("target", config.getName());
                throw GeneratorException.of(PROGRAM_NOT_FOUND, debugInfo);
            }

            try {
                program.add("includes", includes);
                program.add("mainBody", generateNode(model.mainBody));
                program.add("methods", model.methods);
                program.add("notice", "Generated by QRC");
            } catch (IllegalArgumentException e) {
                DebugInfo debugInfo = new DebugInfo(0,0);
                debugInfo.put("target", config.getName());
                throw GeneratorException.of(PROGRAM_NOT_FOUND, debugInfo);
            }


            return program.render();
        }

        private String generateNode(Node node) {
            if (node instanceof WorkflowNode) {
                String name = ((WorkflowNode) node).name;
                ST workflow = group.getInstanceOf(name);

                if (workflow == null) {
                    node.debugInfo.put("target", config.getName());
                    node.debugInfo.put("pattern", name);

                    throw GeneratorException.of(UNSUPPORTED_PATTERN, node.debugInfo);
                }

                int count = 0;
                for (Node child : node.getChildren()) {
                    String childString = generateNode(child);
                    workflow.add("arg" + count, childString);
                    count++;
                }

                if (counterIncrements.containsKey(name)) {
                    for (int i = 0; i < counterIncrements.get(name); ++i) {
                        workflow.add("count" + i, counters.get(name).intValue());
                        counters.get(name).inc();
                    }
                }

                if (config.getIncludes().containsKey(name)) {
                    includes.addAll(config.getIncludes().get(name));
                }

                return workflow.render();
            } else if (node instanceof MethodNode) {
                boolean statement = ((MethodNode) node).statement;
                Method method = ((MethodNode) node).method;
                ST methodNode;

                if (statement) {
                    methodNode = group.getInstanceOf("AtomicSt");
                } else {
                    methodNode = group.getInstanceOf("AtomicExp");
                }

                if (methodNode == null) {
                    DebugInfo debugInfo = new DebugInfo(0, 0);
                    debugInfo.put("target", config.getName());
                    throw GeneratorException.of(statement ? STATEMENT_NOT_FOUND : EXPRESSION_NOT_FOUND, debugInfo);
                }

                try {
                    methodNode.add("name", method.name);

                    for (Node child : node.getChildren()) {
                        String arg = generateNode(child);
                        methodNode.add("args", arg);
                    }
                } catch (IllegalArgumentException e) {
                    DebugInfo debugInfo = new DebugInfo(0, 0);
                    debugInfo.put("target", config.getName());
                    throw GeneratorException.of(statement ? STATEMENT_NOT_FOUND : EXPRESSION_NOT_FOUND, debugInfo);
                }

                return methodNode.render();
            } else if (node instanceof StringNode) {
                return ((StringNode) node).string;
            }  else if (node instanceof ValueNode) {
                return ((ValueNode) node).value;
            } else { // EmptyNode
                return "";
            }
        }
    }
}
